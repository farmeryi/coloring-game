<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Canvas 繪圖工具 RWD 修正版</title>
<style>
  body { margin:0; font-family: Arial, sans-serif; text-align:center; background:#f0f0f0;}
  .controls { margin:10px; display:flex; flex-wrap:wrap; justify-content:center; gap:5px; }
  .color-btn { width:30px; height:30px; display:inline-block; cursor:pointer; border:1px solid #ccc; }
  #canvasContainer { position: relative; margin:auto; max-width: 100%; }
  canvas { border:1px solid black; position:absolute; top:0; left:0; touch-action:none; }
  .upload-section { margin: 10px; padding: 10px; background: white; border-radius: 5px; }
  .upload-btn { margin: 5px; padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
  .upload-btn:hover { background: #45a049; }
  .upload-btn.bg { background: #2196F3; }
  .upload-btn.bg:hover { background: #0b7dda; }
  .layer-info { margin: 5px; font-size: 12px; color: #666; }
  @media(max-width:768px) { .color-btn{width:25px;height:25px;} }
</style>
</head>
<body>

<h2>Canvas 繪圖工具</h2>

<div class="upload-section">
  <div class="layer-info">圖層順序：背景圖 → 畫筆繪圖 → 去背圖（最上層）</div>
  <input type="file" id="uploadBg" accept="image/*" style="display:none" onchange="uploadBackgroundImage(event)">
  <button class="upload-btn bg" onclick="document.getElementById('uploadBg').click()">上傳背景圖</button>
  
  <input type="file" id="uploadOverlay" accept="image/*" style="display:none" onchange="uploadOverlayImage(event)">
  <button class="upload-btn" onclick="document.getElementById('uploadOverlay').click()">上傳去背圖（推薦PNG）</button>
  
  <button class="upload-btn" onclick="clearBackground()">清除背景</button>
  <button class="upload-btn" onclick="clearOverlay()">清除去背圖</button>
</div>

<div class="controls" id="colorPalette"></div>
<div class="controls">
  <button onclick="setEraser()">橡皮擦</button>
  <label>粗細：<input type="range" id="lineWidth" min="1" max="20" value="3" onchange="changeLineWidth(this.value)"></label>
  <button onclick="undo()">復原</button>
  <button onclick="redo()">重做</button>
  <button onclick="clearDraw()">清除畫筆</button>
  <button onclick="downloadCanvas()">下載合成圖</button>
</div>

<div id="canvasContainer">
  <canvas id="bgCanvas"></canvas>
  <canvas id="drawCanvas"></canvas>
  <canvas id="overlayCanvas"></canvas>
</div>

<script>
const bgCanvas = document.getElementById("bgCanvas");
const drawCanvas = document.getElementById("drawCanvas");
const overlayCanvas = document.getElementById("overlayCanvas");

const bgCtx = bgCanvas.getContext("2d");
const ctx = drawCanvas.getContext("2d");
const overlayCtx = overlayCanvas.getContext("2d");

let drawing = false;
let currentColor = "black";
let lineWidth = 3;
let isEraser = false;
let history = [];
let redoHistory = [];
let lastPos = {x:0,y:0};
let bgImage = null;
let overlayImage = null;

// RWD
function resizeCanvas(){
  const container = document.getElementById("canvasContainer");
  const width = Math.min(window.innerWidth-20,600);
  const height = Math.min(window.innerHeight-200,400);
  [bgCanvas, drawCanvas, overlayCanvas].forEach(c=>{
    c.width = width;
    c.height = height;
  });
  redrawBackground();
  redrawDrawLayer();
  redrawOverlay();
}
window.addEventListener('resize', resizeCanvas);

// 觸控與滑鼠事件
function getPos(e){
  const rect = drawCanvas.getBoundingClientRect();
  let clientX, clientY;
  if(e.touches){ clientX=e.touches[0].clientX; clientY=e.touches[0].clientY;}
  else{ clientX=e.clientX; clientY=e.clientY;}
  return { x:(clientX-rect.left)*(drawCanvas.width/rect.width),
           y:(clientY-rect.top)*(drawCanvas.height/rect.height)};
}

function startDraw(e){
  e.preventDefault();
  drawing = true;
  lastPos = getPos(e);
  ctx.beginPath();
  ctx.moveTo(lastPos.x,lastPos.y);
}

function draw(e){
  if(!drawing) return;
  const pos = getPos(e);
  ctx.lineWidth = lineWidth;
  ctx.lineCap = "round";
  ctx.strokeStyle = currentColor;
  ctx.globalCompositeOperation = isEraser ? 'destination-out' : 'source-over';
  ctx.beginPath();
  ctx.moveTo(lastPos.x,lastPos.y);
  ctx.lineTo(pos.x,pos.y);
  ctx.stroke();
  lastPos = pos;
}

function stopDraw(){
  if(!drawing) return;
  drawing=false;
  ctx.closePath();
  saveHistory();
}

// 事件監聽器綁定到繪圖層，但確保不會影響到覆蓋層
drawCanvas.addEventListener("mousedown", startDraw);
drawCanvas.addEventListener("mousemove", draw);
drawCanvas.addEventListener("mouseup", stopDraw);
drawCanvas.addEventListener("mouseout", stopDraw);
drawCanvas.addEventListener("touchstart", startDraw, {passive:false});
drawCanvas.addEventListener("touchmove", draw, {passive:false});
drawCanvas.addEventListener("touchend", stopDraw, {passive:false});

// 也在覆蓋層上添加事件監聽器，讓去背圖上也能繪圖
overlayCanvas.addEventListener("mousedown", startDraw);
overlayCanvas.addEventListener("mousemove", draw);
overlayCanvas.addEventListener("mouseup", stopDraw);
overlayCanvas.addEventListener("mouseout", stopDraw);
overlayCanvas.addEventListener("touchstart", startDraw, {passive:false});
overlayCanvas.addEventListener("touchmove", draw, {passive:false});
overlayCanvas.addEventListener("touchend", stopDraw, {passive:false});

// 顏色與橡皮擦
function setColor(color){ currentColor=color; isEraser=false; }
function setEraser(){ isEraser=true; }

// 粗細
function changeLineWidth(value){ lineWidth=value; }

// 清除畫筆層
function clearDraw(){
  ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  saveHistory();
}

// 歷史紀錄
function saveHistory(){
  const imgData = drawCanvas.toDataURL();
  history.push(imgData);
  redoHistory = [];
  if(history.length > 50) history.shift(); // 限制歷史記錄數量
}

// 復原
function undo(){
  if(history.length>1){
    redoHistory.push(history.pop());
    const img = new Image();
    img.src = history[history.length-1];
    img.onload = ()=>{
      ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      ctx.drawImage(img,0,0,drawCanvas.width,drawCanvas.height);
    }
  }
}

// 重做
function redo(){
  if(redoHistory.length>0){
    const imgData = redoHistory.pop();
    const img = new Image();
    img.src = imgData;
    img.onload = ()=>{
      ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      ctx.drawImage(img,0,0,drawCanvas.width,drawCanvas.height);
    }
    history.push(imgData);
  }
}

// 上傳背景圖片
function uploadBackgroundImage(event){
  const file = event.target.files[0];
  if(!file) return;
  
  // 檢查文件類型
  if(!file.type.startsWith('image/')){
    alert('請選擇圖片文件！');
    event.target.value = '';
    return;
  }
  
  console.log('上傳背景圖片:', file.name, file.type, file.size);
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      console.log('背景圖片載入成功:', img.width, 'x', img.height);
      bgImage = img;
      redrawBackground();
    };
    img.onerror = function() {
      console.error('圖片載入失敗');
      alert('圖片載入失敗，請檢查文件格式！');
    };
    img.src = e.target.result;
  };
  reader.onerror = function() {
    console.error('文件讀取失敗');
    alert('文件讀取失敗！');
  };
  reader.readAsDataURL(file);
  
  // 清空輸入框
  event.target.value = '';
}

// 上傳覆蓋圖片（去背 PNG）
function uploadOverlayImage(event){
  const file = event.target.files[0];
  if(!file) return;
  
  if(!file.type.startsWith('image/')){
    alert('請上傳圖片文件（建議使用 PNG 格式以保持透明效果）！');
    event.target.value = '';
    return;
  }
  
  console.log('上傳去背圖片:', file.name, file.type, file.size);
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      console.log('去背圖片載入成功:', img.width, 'x', img.height);
      overlayImage = img;
      redrawOverlay();
    };
    img.onerror = function() {
      console.error('圖片載入失敗');
      alert('圖片載入失敗，請檢查文件格式！');
    };
    img.src = e.target.result;
  };
  reader.onerror = function() {
    console.error('文件讀取失敗');
    alert('文件讀取失敗！');
  };
  reader.readAsDataURL(file);
  
  // 清空輸入框
  event.target.value = '';
}

// 清除背景
function clearBackground(){
  bgImage = null;
  redrawBackground();
}

// 清除覆蓋層
function clearOverlay(){
  overlayImage = null;
  redrawOverlay();
}

// 重新繪製背景
function redrawBackground(){
  bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
  
  if(bgImage) {
    console.log('重新繪製背景圖片');
    // 保持寬高比，填滿畫布
    const canvasAspect = bgCanvas.width / bgCanvas.height;
    const imgAspect = bgImage.width / bgImage.height;
    
    let drawWidth, drawHeight, drawX, drawY;
    
    if (imgAspect > canvasAspect) {
      // 圖片較寬，以高度為準
      drawHeight = bgCanvas.height;
      drawWidth = drawHeight * imgAspect;
      drawX = (bgCanvas.width - drawWidth) / 2;
      drawY = 0;
    } else {
      // 圖片較高，以寬度為準
      drawWidth = bgCanvas.width;
      drawHeight = drawWidth / imgAspect;
      drawX = 0;
      drawY = (bgCanvas.height - drawHeight) / 2;
    }
    
    try {
      bgCtx.drawImage(bgImage, drawX, drawY, drawWidth, drawHeight);
      console.log('背景圖片繪製完成');
    } catch(e) {
      console.error('繪製背景圖片時發生錯誤:', e);
      alert('繪製背景圖片時發生錯誤！');
    }
  } else {
    console.log('沒有背景圖片需要繪製');
  }
}

// 重新繪製畫筆層
function redrawDrawLayer(){
  if(history.length>0){
    const img = new Image();
    img.src = history[history.length-1];
    img.onload = ()=>{
      ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      ctx.drawImage(img,0,0,drawCanvas.width,drawCanvas.height);
    }
  }else{
    ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  }
}

// 重新繪製覆蓋層（去背圖）
function redrawOverlay(){
  overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
  
  if(overlayImage) {
    console.log('重新繪製覆蓋圖片');
    try {
      // 保持原始尺寸和透明度
      overlayCtx.drawImage(overlayImage, 0, 0, overlayCanvas.width, overlayCanvas.height);
      console.log('覆蓋圖片繪製完成');
    } catch(e) {
      console.error('繪製覆蓋圖片時發生錯誤:', e);
      alert('繪製覆蓋圖片時發生錯誤！');
    }
  } else {
    console.log('沒有覆蓋圖片需要繪製');
  }
}

// 下載合併圖片
function downloadCanvas(){
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = drawCanvas.width;
  tempCanvas.height = drawCanvas.height;
  const tempCtx = tempCanvas.getContext("2d");
  
  // 按順序合併所有圖層
  tempCtx.drawImage(bgCanvas,0,0);        // 背景層
  tempCtx.drawImage(drawCanvas,0,0);      // 繪圖層
  tempCtx.drawImage(overlayCanvas,0,0);   // 覆蓋層（去背圖）
  
  const link = document.createElement("a");
  link.download = "canvas_" + new Date().getTime() + ".png";
  link.href = tempCanvas.toDataURL("image/png");
  link.click();
}

// 36 色調色盤
const colors=[
"#000000","#808080","#C0C0C0","#FFFFFF","#800000","#FF0000",
"#808000","#FFFF00","#008000","#00FF00","#008080","#00FFFF",
"#000080","#0000FF","#800080","#FF00FF","#A52A2A","#FFA500",
"#B8860B","#FFD700","#2E8B57","#90EE90","#20B2AA","#40E0D0",
"#4169E1","#87CEEB","#6A5ACD","#9370DB","#FF1493","#FF69B4",
"#CD5C5C","#F08080","#708090","#D3D3D3","#F5F5DC","#FFE4C4"];

const palette = document.getElementById("colorPalette");
colors.forEach(c=>{
  const btn = document.createElement("div");
  btn.className="color-btn";
  btn.style.backgroundColor=c;
  btn.onclick=()=>setColor(c);
  btn.title = c; // 顯示顏色代碼提示
  palette.appendChild(btn);
});

// 初始化
resizeCanvas();
saveHistory();

// 防止頁面滾動
document.addEventListener('touchmove', function(e) {
  if(e.target.tagName === 'CANVAS') {
    e.preventDefault();
  }
}, {passive: false});

</script>

</body>
</html>
